/*
 * If not stated otherwise in this file or this component's license file the
 * following copyright and licenses apply:
 *
 * Copyright 2018 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

/**
* @file main_aamp.h
* public API for AAMP
*/
#ifndef MAINAAMP_H
#define MAINAAMP_H

#include <vector>
#include <string>

#include <stddef.h>

#ifndef STANDALONE_AAMP
extern "C"
{
	/**
	 *   @brief  Load aamp JS bindings.
	 *
	 *   @param[in]  context - JS Core context.
	 *   @param[in]  playerInstanceAAMP - AAMP instance. NULL creates new aamp instance.
	 *   @return void
	 */
    void aamp_LoadJS(void* context, void* playerInstanceAAMP);

	/**
	 *   @brief  Unload aamp JS bindings.
	 *
	 *   @param[in]  context - JS Core context.
	 *   @return void
	 */
    void aamp_UnloadJS(void* context);
}
#endif

typedef enum
{
	AAMP_EVENT_TUNED = 1, /** Tune success*/
	AAMP_EVENT_TUNE_FAILED, /** Tune failure*/
	AAMP_EVENT_SPEED_CHANGED, /** Speed changed internally*/
	AAMP_EVENT_EOS, /** End of stream*/
	AAMP_EVENT_PLAYLIST_INDEXED, /** Playlist downloaded and indexed*/
	AAMP_EVENT_PROGRESS, /** Progress event with stats. Sent every ~250ms while streaming */
	AAMP_EVENT_CC_HANDLE_RECEIVED, /** Sent when video decoder handle retrieved */
	AAMP_EVENT_JS_EVENT, /** generic event generated by JavaScript binding */
	AAMP_EVENT_VIDEO_METADATA, /**  meta-data of tuned channel*/
	AAMP_EVENT_ENTERING_LIVE, /** event when live point reached*/
	AAMP_EVENT_BITRATE_CHANGED, /** event when bitrate changes */
	AAMP_EVENT_TIMED_METADATA, /** event when subscribe tag parsed*/
	AAMP_EVENT_STATUS_CHANGED, /** event when player status changes */
	AAMP_MAX_NUM_EVENTS
} AAMPEventType;

typedef enum
{
	AAMP_TUNE_INIT_FAILED, /** Tune failure due to initialization error*/
	AAMP_TUNE_MANIFEST_REQ_FAILED, /** Tune failure caused by manifest fetch failure*/
	AAMP_TUNE_AUTHORISATION_FAILURE, /** Not authorised to view the content*/
	AAMP_TUNE_FRAGMENT_DOWNLOAD_FAILURE, /**  When fragment download fails for 5 consecutive fragments*/
	AAMP_TUNE_UNTRACKED_DRM_ERROR, /**  DRM error*/
	AAMP_TUNE_DRM_INIT_FAILED, /** DRM initialization failure */
	AAMP_TUNE_DRM_DATA_BIND_FAILED, /** InitData binding with DRM failed */
	AAMP_TUNE_DRM_CHALLENGE_FAILED, /** DRM key request challenge generation failed */
	AAMP_TUNE_LICENCE_TIMEOUT, /** DRM license request timeout */
	AAMP_TUNE_LICENCE_REQUEST_FAILED, /** DRM license got invalid response */
	AAMP_TUNE_INVALID_DRM_KEY, /** DRM reporting invalid license key */
	AAMP_TUNE_UNSUPPORTED_STREAM_TYPE, /** Unsupported stream type */
	AAMP_TUNE_FAILED_TO_GET_KEYID, /** Failed to parse key id from init data*/
	AAMP_TUNE_FAILED_TO_GET_ACCESS_TOKEN, /** Failed to get session token from AuthService*/
	AAMP_TUNE_CORRUPT_DRM_DATA, /** DRM failure due to corrupt drm data, self heal might clear further errors*/
	AAMP_TUNE_DRM_DECRYPT_FAILED, /** DRM Decryption Failed for Fragments */
	AAMP_TUNE_GST_PIPELINE_ERROR, /** Playback failure due to error from GStreamer pipeline or associated plugins */
#ifdef AAMP_JS_PP_STALL_DETECTOR_ENABLED
	AAMP_TUNE_PLAYBACK_STALLED, /** Playback was stalled due to valid fragments not available in playlist */
#endif
	AAMP_TUNE_CONTENT_NOT_FOUND, /** The resource was not found at the URL provided (HTTP 404) */
	AAMP_TUNE_FAILURE_UNKNOWN /**  Unknown failure */
}AAMPTuneFailure;

typedef struct _TuneFailureMap
{
        AAMPTuneFailure tuneFailure;
        int code;
        const char* description;
} TuneFailureMap;

/*
 * Mapping all required status codes based on JS player requirement. These requirements may be forced by psdk player
 * AAMP may not use all the statuses mentioned below
 * Mainly required statuses - idle, initializing, initialized, preparing, prepared, playing, paused, seek, complete and error
 */
typedef enum
{
	eSTATE_IDLE,         /** 0  - Player is idle */

	eSTATE_INITIALIZING, /** 1  - Player is initializing a particular content */

	eSTATE_INITIALIZED,  /** 2  - Player has initialized for a content successfully */

	eSTATE_PREPARING,    /** 3  - Player is loading all associated resources */

	eSTATE_PREPARED,     /** 4  - Player has loaded all associated resources successfully */

	eSTATE_BUFFERING,    /** 5  - Player is in buffering state */

	eSTATE_PAUSED,       /** 6  - Playback is paused */

	eSTATE_SEEKING,      /** 7  - Seek is in progress */

	eSTATE_PLAYING,      /** 8  - Playback is in progress */

	eSTATE_STOPPING,     /** 9  - Player is stopping the playback */

	eSTATE_STOPPED,      /** 10 - Player has stopped playback successfully */

	eSTATE_COMPLETE,     /** 11 - Playback completed */

	eSTATE_ERROR,        /** 12 - Error encountered and playback stopped */

	eSTATE_RELEASED      /** 13 - Player has released all resources for playback */

} PrivAAMPState;

#define MAX_LANGUAGE_COUNT 4
#define MAX_LANGUAGE_TAG_LENGTH 4
#define MAX_ERROR_DESCRIPTION_LENGTH 128
#define MAX_BITRATE_COUNT 10

struct AAMPEvent
{
	AAMPEventType type;

	union
	{
		struct
		{
			double durationMiliseconds; // current size of time shift buffer
			double positionMiliseconds; // current play/pause position relative to tune time - starts at zero)
			float playbackSpeed; // current trick speed (1.0 for normal play rate)
			double startMiliseconds; // time shift buffer start position (relative to tune time - starts at zero)
			double endMiliseconds;  // time shift buffer end position (relative to tune time - starts at zero)
		} progress;

		struct
		{
			float rate;
		} speedChanged;

		struct
		{
			int time;
			int bitrate;
			char description[128];  
			int width;
			int height;
		} bitrateChanged;

		struct
		{
			long durationMiliseconds;
			int languageCount;
			char languages[MAX_LANGUAGE_COUNT][MAX_LANGUAGE_TAG_LENGTH];
			int bitrateCount;
			long bitrates[MAX_BITRATE_COUNT];
			int width;
			int height;
			bool hasDrm;
		} metadata;

		struct
		{
			unsigned long handle;
		} ccHandle;

		struct
		{
			const char* szName;
			double timeMilliseconds; // current play/pause position relative to tune time - starts at zero)
			const char* szContent;
		} timedMetadata;

		struct
		{
			const char* szEventType;
			void*  jsObject;
		} jsEvent;

		struct
		{
			AAMPTuneFailure failure;
			int code;
			char description[MAX_ERROR_DESCRIPTION_LENGTH];
		} mediaError;

		struct
		{
			PrivAAMPState state;
		} stateChanged;

	} data;

	AAMPEvent()
	{
	}
	AAMPEvent(AAMPEventType t) : type(t)
	{
	}
};

class AAMPEventListener
{
public:
	virtual void Event(const AAMPEvent& event) = 0;
	virtual ~AAMPEventListener(){};
};

typedef enum
{
	eMEDIATYPE_VIDEO,
	eMEDIATYPE_AUDIO,
	eMEDIATYPE_MANIFEST,
	eMEDIATYPE_LICENCE
} MediaType;

typedef enum output_format_e
{
	FORMAT_INVALID,
	FORMAT_MPEGTS,
	FORMAT_ISO_BMFF,
	FORMAT_AUDIO_ES_AAC,
	FORMAT_AUDIO_ES_AC3,
	FORMAT_AUDIO_ES_EC3,
	FORMAT_VIDEO_ES_H264,
	FORMAT_VIDEO_ES_HEVC,
	FORMAT_VIDEO_ES_MPEG2,
	FORMAT_NONE
}StreamOutputFormat;

typedef enum
{
	VIDEO_ZOOM_FULL, /** Zoom to full screen*/
	VIDEO_ZOOM_NONE /** Reset zoom*/
} VideoZoomMode;

class StreamSink
{ // GStreamer Abstraction - with implementations in AAMPGstPlayer and gstaamp plugin
public:
	virtual void Configure(StreamOutputFormat format, StreamOutputFormat audioFormat)=0;
	virtual void Send( MediaType mediaType, const void *ptr, size_t len, double fpts, double fdts, double duration)= 0;
	virtual void Send( MediaType mediaType, struct GrowableBuffer* buffer, double fpts, double fdts, double duration)= 0;
	virtual void EndOfStreamReached(MediaType mediaType){}
	virtual void Stream(void){}
	virtual void Stop(bool keepLastFrame){}
	virtual void DumpStatus(void){}
	virtual void Flush(double position = 0, float rate = 1.0){}
	virtual void SelectAudio(int index){}
	virtual void Pause(bool pause){}
	virtual long GetPositionMilliseconds(void){ return 0; };
	virtual unsigned long getCCDecoderHandle(void) { return 0; };
	virtual void SetVideoRectangle(int x, int y, int w, int h){};
	virtual void SetVideoZoom(VideoZoomMode zoom){};
	virtual void SetVideoMute(bool muted){};
	virtual void SetAudioVolume(int volume){};
	virtual ~StreamSink(){};
	virtual bool Discontinuity( MediaType mediaType) = 0;
	virtual bool IsCacheEmpty(MediaType mediaType){ return true; };
	virtual void NotifyFragmentCachingComplete(){};
	virtual void GetVideoSize(int &w, int &h){};
	virtual void QueueProtectionEvent(const char *protSystemId, const void *ptr, size_t len) {};
	virtual void ClearProtectionEvent() {};
};


class PlayerInstanceAAMP
{ // new public API
public:
	/**
	 *   @brief Constructor.
	 *
	 *   @param  streamSink - custom stream sink, NULL for default.
	 *   @return None
	 */
	PlayerInstanceAAMP(StreamSink* streamSink = NULL);

	/**
	 *   @brief Destructor.
	 *
	 *   @return None
	 */
	~PlayerInstanceAAMP();

	/**
	 *   @brief Tune to a URL.
	 *
	 *   @param  url - HTTP/HTTPS url to be played.
	 *   @return void
	 */
	void Tune(const char *url);

	/**
	 *   @brief Stop playback and release resources.
	 *
	 *   @return void
	 */
	void Stop(void);

	/**
	 *   @brief Set playback rate.
	 *
	 *   @param  rate - Rate of playback.
	 *   @param  overshoot - overshoot correction in milliseconds.
	 *   @return void
	 */
	void SetRate(float rate, int overshoot=0);

	/**
	 *   @brief Seek to a time.
	 *
	 *   @param  secondsRelativeToTuneTime - Seek position for VOD,
	 *           relative position from first tune command.
	 *   @return void
	 */
	void Seek(double secondsRelativeToTuneTime);

	/**
	 *   @brief Seek to live point.
	 *
	 *   @return void
	 */
	void SeekToLive(void);

	/**
	 *   @brief Seek to a time and playback with a new rate.
	 *
	 *   @param  rate - Rate of playback.
	 *   @param  secondsRelativeToTuneTime - Seek position for VOD,
	 *           relative position from first tune command.
	 *   @return void
	 */
	void SetRateAndSeek(float rate, double secondsRelativeToTuneTime);

	/**
	 *   @brief Register event handler.
	 *
	 *   @param  eventListener - pointer to implementation of AAMPEventListener to receive events.
	 *   @return void
	 */
	void RegisterEvents(AAMPEventListener* eventListener);

	/**
	 *   @brief Set video rectangle.
	 *
	 *   @param  x - horizontal start position.
	 *   @param  y - vertical start position.
	 *   @param  w - width.
	 *   @param  h - height.
	 *   @return void
	 */
	void SetVideoRectangle(int x, int y, int w, int h);

	/**
	 *   @brief Set video zoom.
	 *
	 *   @param  zoom - zoom mode.
	 *   @return void
	 */
	void SetVideoZoom(VideoZoomMode zoom);

	/**
	 *   @brief Enable/ Disable Video.
	 *
	 *   @param  muted - true to disable video, false to enable video.
	 *   @return void
	 */
	void SetVideoMute(bool muted);

	/**
	 *   @brief Set Audio Volume.
	 *
	 *   @param  volume - Minimum 0, maximum 100.
	 *   @return void
	 */
	void SetAudioVolume(int volume);

	/**
	 *   @brief Set Audio language.
	 *
	 *   @param  language - Language of audio track.
	 *   @return void
	 */
	void SetLanguage(const char* language);

	/**
	 *   @brief Set array of subscribed tags.
	 *
	 *   @param  subscribedTags - Array of subscribed tags.
	 *   @return void
	 */
	void SetSubscribedTags(std::vector<std::string> subscribedTags);


	/**
	 *   @brief Load AAMP JS object in the specified JS context.
	 *
	 *   @param  context - JS context.
	 *   @return void
	 */
	void LoadJS(void* context);

	/**
	 *   @brief Load AAMP JS object in the specified JS context.
	 *
	 *   @param  context - JS context.
	 *   @return void
	 */
	void UnloadJS(void* context);

	// Support JS event target interface

	/**
	 *   @brief Support multiple listeners for multiple event type
	 *
	 *   @param  eventType - type of event.
	 *   @param  eventListener - listener for the eventType.
	 *   @return void
	 */
	void AddEventListener(AAMPEventType eventType, AAMPEventListener* eventListener);

	/**
	 *   @brief Remove event listener for eventType.
	 *
	 *   @param  eventType - type of event.
	 *   @param  eventListener - listener to be removed for the eventType.
	 *   @return void
	 */
	void RemoveEventListener(AAMPEventType eventType, AAMPEventListener* eventListener);

	/**
	 *   @brief To check playlist type.
	 *
	 *   @param  void
	 *   @return bool - True if live content, false otherwise
	 */
	bool IsLive();

	// Ad insertion support

	/**
	 *   @brief Schedule insertion of ad at given position.
	 *
	 *   @param  url - HTTP/HTTPS url of the ad
	 *   @param  positionSeconds - position at which ad shall be inserted
	 *   @return void
	 */
	void InsertAd(const char *url, double positionSeconds);

	/**
	 *   @brief Get current audio language.
	 *
	 *   @param  void
	 *   @return char* - current audio language
	 */
	char* GetCurrentAudioLanguage();

	/**
	 *   @brief Add/Remove a custom HTTP header and value.
	 *
	 *   @param  headerName - Name of custom HTTP header
	 *   @param  subscribedTags - Value to be pased along with HTTP header.
	 *   @return void
	 */
	void AddCustomHTTPHeader(std::string headerName, std::vector<std::string> headerValue);

	/**
	 *   @brief Set Licence Server URL.
	 *
	 *   @param  url - URL of the server to be used for license requests
	 *   @return void
	 */
	void SetLicenceServerURL(char *url);

	/**
	 *   @brief Indicates if session token has to be used with license request or not.
	 *
	 *   @param  isAnonymous - True if session token should be blank and false otherwise.
	 *   @return void
	 */
	void SetAnonymousRequest(bool isAnonymous);

	/**
	 *   @brief Set VOD Trickplay FPS.
	 *
	 *   @param  vodTrickplayFPS - FPS to be used for VOD Trickplay
	 *   @return void
	 */
	void SetVODTrickplayFPS(int vodTrickplayFPS);

	/**
	 *   @brief Set Linear Trickplay FPS.
	 *
	 *   @param  linearTrickplayFPS - FPS to be used for Linear Trickplay
	 *   @return void
	 */
	void SetLinearTrickplayFPS(int linearTrickplayFPS);

	/**
	 *   @brief To set the error code to be used for playback stalled error.
	 *
	 *   @param  errorCode - error code for playback stall errors.
	 *   @return void
	 */
	void SetStallErrorCode(int errorCode);

	/**
	 *   @brief To set the timeout value to be used for playback stall detection.
	 *
	 *   @param  timeoutMS - timeout in milliseconds for playback stall detection.
	 *   @return void
	 */
	void SetStallTimeout(int timeoutMS);

	class PrivateInstanceAAMP *aamp;
private:
	StreamSink* mInternalStreamSink;
	void* mJSBinding_DL;
};

#endif // MAINAAMP_H
