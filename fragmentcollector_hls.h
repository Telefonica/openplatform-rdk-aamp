/*
 * If not stated otherwise in this file or this component's license file the
 * following copyright and licenses apply:
 *
 * Copyright 2018 RDK Management
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/
#ifndef FRAGMENTCOLLECTOR_HLS_H
#define FRAGMENTCOLLECTOR_HLS_H

#include "StreamAbstractionAAMP.h"
#include "tsprocessor.h"
#include "drm.h"
#ifdef AAMP_CONTENT_METADATA_IPDVR_ENABLED
#include "ZeroDrmAccessAdapter.h"
#endif

#define MAX_PROFILE 128 // TODO: remove limitation
#define FOG_FRAG_BW_IDENTIFIER "bandwidth-"
#define FOG_FRAG_BW_IDENTIFIER_LEN 10
#define FOG_FRAG_BW_DELIMITER "-"
typedef struct HlsStreamInfo: public StreamInfo
{ // #EXT-X-STREAM-INFs
	long program_id;
	const char *audio;
	const char *codecs;
	const char *uri;

	// rarely present
	long averageBandwidth;
	double frameRate;
	const char *closedCaptions;
	const char *subtitles;
} HlsStreamInfo;

typedef struct MediaInfo
{ // #EXT-X-MEDIA
	MediaType type;
	const char *group_id;
	const char *name;
	const char *language;
	bool autoselect;
	bool isDefault;
	const char *uri;

	// rarely present
	int channels;
	const char *instreamID;
	bool forced;
} MediaInfo;

struct IndexNode
{
	double completionTimeSecondsFromStart;
	const char *pFragmentInfo;
	int drmMetadataIdx;
};

class TrackState : public MediaTrack
{
public:
	TrackState(TrackType type, class StreamAbstractionAAMP_HLS* parent, PrivateInstanceAAMP* aamp, const char* name);
	~TrackState();
	void Start();
	void Stop();
	void RunFetchLoop();
	double IndexPlaylist();
	void ABRProfileChanged(void);
	char *GetNextFragmentUriFromPlaylist();
	void UpdateDrmIV(const char *ptr);
	void UpdateDrmCMSha1Hash(const char *ptr);
	void SetDrmContextUnlocked();
	bool DrmDecrypt(CachedFragment* cachedFragment, ProfilerBucketType bucketType);
	void FetchPlaylist();

	/**
	 * @brief Get period information of next fragment
	 *
	 * @param[out] periodIdx Index of the period in which next fragment belongs
	 * @param[out] offsetFromPeriodStart Offset from start position of the period
	 */
	void GetNextFragmentPeriodInfo(int &periodIdx, double &offsetFromPeriodStart);

	/**
	 * @brief Get start position of the period corresponding to the index.
	 *
	 * @param[in] periodIdx Index of period
	 * @return Start position of the period
	 */
	double GetPeriodStartPosition(int periodIdx);

	/**
	 * @brief Get total number of periods in playlist based on discontinuity
	 *
	 * @return Number of periods in playlist
	 */
	int GetNumberOfPeriods();

private:
	char *GetFragmentUriFromIndex();
	void FlushIndex();
	void FetchFragment();
	bool FetchFragmentHelper(long &http_error, bool &decryption_error);
	void RefreshPlaylist(void);
	StreamAbstractionAAMP* GetContext();
	void InjectFragmentInternal(CachedFragment* cachedFragment, bool &stopInjection, bool &fragmentDiscarded);
	char *FindMediaForSequenceNumber();

public:
	char effectiveUrl[MAX_URI_LENGTH]; /**< uri associated with downloaded playlist (takes into account 302 redirect) */
	char playlistUrl[MAX_URI_LENGTH]; /**< uri associated with downloaded playlist */
	GrowableBuffer playlist; /**< downloaded playlist contents */
		
	GrowableBuffer index; /**< packed IndexNode records for associated playlist */
	int indexCount; /**< number of indexed fragments in currently indexed playlist */
	int currentIdx; /**< index for currently-presenting fragment used during FF/REW (-1 if undefined) */
	char fragmentURIFromIndex[MAX_URI_LENGTH]; /**< storage for uri generated by GetFragmentUriFromIndex */
	long long indexFirstMediaSequenceNumber; /**< first media sequence number from indexed manifest */

	char *fragmentURI; /**< pointer (into playlist) to URI of current fragment-of-interest */
	long long lastPlaylistDownloadTimeMS; /**< UTC time at which playlist was downloaded */
	int byteRangeLength; /**< state for #EXT-X-BYTERANGE fragments */
	int byteRangeOffset; /**< state for #EXT-X-BYTERANGE fragments */

	long long nextMediaSequenceNumber; /**< media sequence number following current fragment-of-interest */
	double playlistPosition; /**< playlist-relative time of most recent fragment-of-interest; -1 if undefined */
	double playTarget; /**< initially relative seek time (seconds) based on playlist window, but updated as a play_target */

	double targetDurationSeconds; /**< copy of #EXT-X-TARGETDURATION to manage playlist refresh frequency */

	StreamOutputFormat streamOutputFormat; /**< type of data encoded in each fragment */
	TSProcessor* playContext; /**< state for s/w demuxer / pts/pcr restamper module */
	struct timeval startTimeForPlaylistSync; /**< used for time-based track synchronization when switching between playlists */
	double playTargetOffset; /**< For correcting timestamps of streams with audio and video tracks */
	bool discontinuity; /**< Set when discontinuity is found in track*/
	StreamAbstractionAAMP_HLS* context; /**< To get  settings common across tracks*/
	bool fragmentEncrypted; /**< In DAI, ad fragments can be clear. Set if current fragment is encrypted*/
	struct DrmInfo mDrmInfo;
	unsigned char* mCMSha1Hash;
	long long mDrmTimeStamp;
	int mDrmMetaDataIndexPosition;
	GrowableBuffer mDrmMetaDataIndex;  /**< DrmMetadata records for associated playlist */
	int mDrmMetaDataIndexCount; /**< number of DrmMetadata records in currently indexed playlist */
private:
	bool refreshPlaylist;
	pthread_t fragmentCollectorThreadID;
	bool fragmentCollectorThreadStarted;
	int manifestDLFailCount;
	double parsedLastValidFragmentAt;
	std::map<int, double> mPeriodPositionIndex;  /**< period start position mapping of associated playlist */
};

class StreamAbstractionAAMP_HLS;
class PrivateInstanceAAMP;

class StreamAbstractionAAMP_HLS : public StreamAbstractionAAMP
{
public:
	double IndexPlaylist(TrackState *trackState);

	StreamAbstractionAAMP_HLS(class PrivateInstanceAAMP *aamp,double seekpos, float rate, bool enableThrottle);

	~StreamAbstractionAAMP_HLS();
	void DumpProfiles(void);
	//void SetRate(float rate, double seek_pos );
	void Start();
	void Stop(bool clearChannelData);
	bool IsLive();
	bool Init(TuneType tuneType);
	void GetStreamFormat(StreamOutputFormat &primaryOutputFormat, StreamOutputFormat &audioOutputFormat);
	double GetStreamPosition() { return seekPosition; }
	double GetFirstPTS();
	MediaTrack* GetMediaTrack(TrackType type);
//private:
	// TODO: following really should be private, but need to be accessible from callbacks

	TrackState* trackState[AAMP_TRACK_COUNT];
	float rate;
	float maxIntervalBtwPlaylistUpdateMs;

	PlaylistType playlistType;
	bool hasEndListTag;

	GrowableBuffer mainManifest;

	bool allowsCache;

	int profileCount;
	HlsStreamInfo streamInfo[MAX_PROFILE];

	int mediaCount;
	MediaInfo mediaInfo[MAX_PROFILE];

	double seekPosition;
	int mTrickPlayFPS;
	bool enableThrottle;
	bool firstFragmentDecrypted;
	bool mStartTimestampZero;
	bool newTune;

	void ParseMainManifest(char *ptr);
	const char *GetPlaylistURI(TrackType trackType, StreamOutputFormat* format = NULL);
#ifdef AAMP_HARVEST_SUPPORT_ENABLED
	void HarvestFile(const char * url, GrowableBuffer* buffer, bool isFragment, const char* prefix = NULL);
#endif
#ifdef AAMP_CONTENT_METADATA_IPDVR_ENABLED
	// For contentMetadata , there is no rotation planned as per Kyong's mail .
 	// So we dont need Metadata per track, keeping it only one per playback.
        bool ZDrmDecrypt( CachedFragment * cachedFragment, ProfilerBucketType bucketTypeFragmentDecrypt);
	ZDrmContextData *mZDrmMetadata;
#endif
	bool mNetworkDownDetected;
	int lastSelectedProfileIndex; //to restore in case of playlist download failure
protected:
	int GetProfileCount(){return profileCount;}
	StreamInfo* GetStreamInfo(int idx){ return &streamInfo[idx];}
private:
	void SyncTracks( double trackDuration[]);
	void SyncVODTracks();
	bool skipAudioFetchOnNextIteration;
	int segDLFailCount;
	int segDrmDecryptFailCount;
};

#endif // FRAGMENTCOLLECTOR_HLS_H
